package com.kh.simndo.common.util.file;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import com.kh.toy.common.code.ConfigCode;
import com.kh.toy.common.code.ErrorCode;
import com.kh.toy.common.exception.ToAlertException;
import com.oreilly.servlet.multipart.FilePart;
import com.oreilly.servlet.multipart.MultipartParser;
import com.oreilly.servlet.multipart.ParamPart;
import com.oreilly.servlet.multipart.Part;

public class FileUtil {

	// 파일 업로드 하구
	// 파일업로드 정보 (파일 테이블에 저장할 파일 메타 정보)
	// 파라미터 값
	// 이 두 값을 저장해서 Map에담아 return
	private final int maxSize = 1024 * 1024 * 10;
	// 메서드 분리하면  
	Map<String, List> multiParamMap = new HashMap<String, List>();
	
	// 기능분리
	// 파일업로드 - 
	// 	renameFileName 생성(getRenameFileName)
	// 	서브 저장경로 생성 (getSubPath) 
	// 	저장경로를 생성하고 파일 저장 getFileData
	// 파일 메타정보, 파라미터를 Map에 저장 - 파라미터 저장 / 파일 메타정보 저장
	
	private List<String> getParamValue(ParamPart params) throws UnsupportedEncodingException{
		String paramName = params.getName();
		// 여기서 인코딩 지정해주기, 안해주면 인코딩 깨진다!
		String paramValue = params.getStringValue("UTF-8");

		// 파라미터를 저장할 리스트
		List<String> paramList;

		// 처음이라면은
		if (multiParamMap.get(paramName) == null) {
			paramList = new ArrayList<String>();
			paramList.add(paramValue);

		} else {
			paramList = multiParamMap.get(paramName);
			paramList.add(paramValue);
		}
		
		return paramList;
	}
	
	private FileVo getFileData(FilePart userFile) throws UnsupportedEncodingException {
		// 파일 선언
		// 파일제목 인코딩 문제 해결! 파일제목 인코딩이 깨져서 바이트로바꾸고 다시만드는거로
		String originFileName = new String(userFile.getFileName().getBytes("iso-8859-1"), "UTF-8");
		// 파일을 저장할때는 유니크한 파일명으로 저장
		String renameFileName = getRenameFileName(originFileName);
		//저장경로
		//String savePath = ConfigCode.UPLOAD_PATH + getSubPath();
		// 이 정보들을 vo에 저장해주기
		FileVo fileData = new FileVo();
		fileData.setOriginFileName(originFileName);
		fileData.setRenameFileName(renameFileName);
		//fileData.setSavePath(savePath);
		
		return fileData;
		
	}
	
	private void saveFile(FilePart userFile, FileVo fileData) throws IOException {
		new File(fileData.getSavePath()).mkdirs();
		//File file = new File(fileData.getSavePath()+ fileData.getRenameFileName());
		File file = new File(ConfigCode.UPLOAD_PATH + fileData.getSavePath() + fileData.getRenameFileName()); 
		userFile.writeTo(file);
	}
	
	private String getSubPath() {
		// 저장경로 생성 UPLOAD_PATH안에 날짜별로 나누기로 했으니깐
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);
		int month = cal.get(Calendar.MONTH) + 1;
		int date = cal.get(Calendar.DAY_OF_MONTH);

		String subPath = year + "/" + month + "/" + date + "/";
		
		return subPath;
	}
	
	private String getRenameFileName(String originFileName) {

		// 유니크한 파일명 생성
		UUID renameFileID = UUID.randomUUID();
		// 마지막 . 을 기준으로 . 뒤의 문자열까지를 잘라 반환 : 확장자
		String renameFileName = renameFileID.toString()
				+ originFileName.substring(originFileName.lastIndexOf("."));

		return renameFileName;
	}

	public Map<String, List> fileUpload(HttpServletRequest request) {

		// HttpServletRequest를 해야 MultipartParser를 쓸수있으니깐
		// 메타정보 저장할 리스트
		List<FileVo> fileDataList = new ArrayList<FileVo>();

	
		MultipartParser mp;
		try {
			mp = new MultipartParser(request, maxSize);
			Part part;

			while ((part = mp.readNextPart()) != null) {
				// 파일이 아닌 파라미터라면
				if (part.isParam()) {
					// 다운캐스팅 해야 메서드 쓸수있다.
					ParamPart params = (ParamPart) part;
					// 코드가 줄으면 좋긴하지만 가독성면을 우선으로 여기는게 좋음
					List<String> paramList = getParamValue(params);
					multiParamMap.put(params.getName(), paramList);

				} else if(part.isFile()) {// 파라미터가 파일이라면
					//파일첨부 하든 안하든 isFile가 돌게된다. 첨부안하면 null로 도나봄..
					// 분기처리 필요
					FilePart userFile = (FilePart) part;
					
					//업로드 된 파일이 존재해야 getFileName null이 아니다!
					if(userFile.getFileName() != null) {
						//file테이블에 저장할 파일 메타 정보를 반환 받고
						FileVo fileData = getFileData(userFile);
						//fileDataList에 파일메타정보를 저장
						fileDataList.add(fileData);
						//파일을 업로드			
						saveFile(userFile, fileData);
					}
				}
			}
			
			multiParamMap.put("fileData", fileDataList);
		} catch (IOException e) {
			throw new ToAlertException(ErrorCode.FILE01,e);
		}

		return multiParamMap;
	}
	
	//파일삭제
	public void deletFile(String path) {
		File file = new File(path);
		file.delete();
	}

	//파일 다운로드
	// 원본파일명으로 저장하게하는게 좀 귀찮긴함
	// 오리지널파일네임과 리네임파일네임을 숨겨서 보내서 다운로드 버튼 누를때 숨겨서 보낸 값을 받아서 보낸다.
	
}
